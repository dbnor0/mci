{
  module Grammar where
}

%name grammar
%tokentype { Token }
%error { parseError }

%token
  int         { TokenInt $$ }
  '+'         { TokenPlus }
  '-'         { TokenMinus }
  '*'         { TokenTimes }
  '/'         { TokenDiv }
  '('         { TokenLParen }
  ')'         { TokenRParen }

%% 

Exp     : Exp '+' Term            { Plus $1 $3 }
        | Exp '-' Term            { Minus $1 $3 }
        | Term                    { Term $1 }

Term    : Term '*' Factor         { Times $1 $3 }
        | Term '/' Factor         { Div $1 $3 }
        | Factor                  { Factor $1 }

Factor  : int                     { Int $1 }
        | '(' Exp ')'             { Paren $1 }

{
  parseError :: [Token] -> a
  parseError _ = error "Parser error"

  data Exp
    = Plus Exp Term
    | Minus Exp Term
    | Term Term
    deriving (Eq, Show)

  data Term
    = Times Term Factor
    | Div Term Factor
    | Factor Factor
    deriving (Eq, Show)

  data Factor
    = Int Int
    | Paren Exp
    deriving (Eq, Show)

  data Token 
    = TokenInt Int
    | TokenPlus
    | TokenMinus
    | TokenTimes
    | TokenDiv
    | TokenLParen
    | TokenRParen
    deriving (Eq, Show)

lexer :: String -> [Token]
lexer []       = []
lexer s@(c:cs)
  | isSpace c  = lexer cs
  | isDigit c  = lexNum s
lexer ('+':cs) = TokenPlus : lexer cs
lexer ('-':cs) = TokenMinus : lexer cs
lexer ('*':cs) = TokenTimes : lexer cs
lexer ('/':cs) = TokenDiv : lexer cs
lexer ('(':cs) = TokenLParen : lexer cs
lexer (')':cs) = TokenRParen : lexer cs

lexNum cs = TokenInt (read num) : lexer rest
  where (num, rest) = span isDigit cs

main = getContents >>= print . grammar . lexer
}